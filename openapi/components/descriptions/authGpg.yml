tag: |
  > GPGAuth is the legacy authentication method, and will eventually be dropped in favor of JWT-based authentication.

  ### Multi-step authentication process

  When using GPGAuth-based authentication, the whole process is divided in multiple steps, each one with a specific use-case.

  
  #### Stage 0 - Server's identity verification

  > This step is optional, although recommended.

  In this step, the client challenges the server's identity.

  In order to do that, the client generates a challenge token, composed of different parts separated by pipes:

  - Protocol version (`gpgauthv1.3.0`)
  - Length of UUID (`36`)
  - Said UUID
  - Protocol version again

  An example of said challenge string could be `gpgauthv1.3.0|36|10e2074b-f610-42be-8525-100d4e68c481|gpgauthv1.3.0`.
  
  This challenge token is then encrypted with the sever's public key, obtained with a `GET` request to `/auth/verify.json`.

  The total payload for server verification has the following structure:

  ```json
  {
    "data": {
      "gpg_auth": {
        "keyid": "<user's key fingerprint>",
        "server_verify_token": "<pgp_encrypt('gpgauthv1.3.0|36|10e2074b-f610-42be-8525-100d4e68c481|gpgauthv1.3.0', public_server_key)>"
      }
    }
  }
  ```

  If the user's key fingerprint is known to the server and the server was able to decrypt and validate the challenge string and its format,
  the decrypted challenge string is sent in the reply's `X-GPGAuth-Verify-Response` header.

  This proves that the server is really who it says it is.


  #### Stage 1 - Getting the challenge for client's private key verification

  Now that we verified the server's identity, the server wants to verify our identity.
  In order to do that, we need to tell the server who the client claims to be:

  ```json
  {
    "data": {
      "gpg_auth": {
        "keyid": "<user's key fingerprint>"
      }
    }
  }
  ```

  This payload is then sent in a `POST` request to the `/auth/login.json` endpoint.

  The server replies with an encrypted challenge string in the `X-GPGAuth-User-Auth-Token` header.
  This challenge string has the same format that the one described in stage 0.

  This challenge string is encrypted with the user's public key and signed with the server's key.

  
  #### Stage 2 - Verifying client's private key verification

  Once this challenge string has been decrypted, it has to be sent to the server in a `POST`
  request to `/auth/login.json` in a payload such as:

  ```json
  {
    "data": {
      "gpg_auth": {
        "keyid": "<user's key fingerprint>",
        "user_token_result": "<decrypted challenge string such as 'gpgauthv1.3.0|36|b0a39f7a-a09a-47d5-9180-0bb03c91406f|gpgauthv1.3.0'>"
      }
    }
  }
  ```

  The server now has validated the client's identity, and sets a few headers in its reply:

  - `X-GPGAuth-Authenticated` is set to `true`
  - A cookie named `passbolt_session` used for session identification
  - A cookie named `csrfToken` that the client needs to send in each subsequent authenticated request as a custom header named: `X-CSRF-Token`

  ðŸŽ‰ You are fully authenticated and ready to use the API!
